<!DOCTYPE html>
  <html>
    <head>
      <!--Import Google Icon Font-->
      <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
      <!--Import materialize.css-->
      <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0-beta/css/materialize.min.css">
      <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/obsidian.min.css">


      <!--Let browser know website is optimized for mobile-->
      <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
      <style>
	header, main, footer {
	padding-left: 300px;
	}

	@media only screen and (max-width : 992px) {
	header, main, footer {
        padding-left: 0;
	}
	}
      </style>
    </head>

    <body>
      <ul id="slide-out" class="sidenav sidenav-fixed">
	<li><a href="#!">First Sidebar Link</a></li>
	<li><a href="#!">Second Sidebar Link</a></li>
      </ul>
      <div>
	<a href="#" data-target="slide-out" class="sidenav-trigger"><i class="material-icons right hide-on-large-only">menu</i></a>
      </div>
      <main class="container">
	<h1 id="contracttesting">contract-testing</h1>
<hr />
<p>A lightweight Pythonic testing framework to ensure inter-microservice compatibility through contracts accessible via an
OPTIONS request to any configured endpoint</p>
<p>Additionally, this framework creates a self-documenting API which meets the Swagger/OpenAPI specifications</p>
<h2 id="installation">Installation</h2>
<hr />
<p>From GitLab via ssh</p>
<pre><code class="bash language-bash">$ pip install git+ssh://git@gitlab.encirca.auto.pioneer.com/encirca-microservices/contract-testing.git#egg=contracttesting
</code></pre>
<p>From GitLab via https</p>
<pre><code class="bash language-bash">$ pip install git+https://gitlab.encirca.auto.pioneer.com/encirca-microservices/contract-testing.git#egg=contracttesting
</code></pre>
<h2 id="basicusage">Basic Usage</h2>
<hr />
<h3 id="1addcontractstotestendpointdependencies">1. Add contracts to test endpoint dependencies</h3>
<p>To ensure continued compatibility between microservices, contracts, in the form of Marshmallow schemas, are created
to verify that the OPTIONS model of an external microservice endpoint dependency represents and returns data in an
expected format</p>
<p>By convention, these models should be created in the chlalicelib/models/contracts/ directory</p>
<p>The <code>@contract</code> decorator is used to list an external microservice endpoint dependency</p>
<pre><code class="python language-python">from marshmallow import Schema, fields
from contracttesting.handshake import contract


@contract('users', '/users?age=24', method=['GET'], many=True)
class User(Schema):
    userID = fields.UUID(required=True, description="A UUID to identify the User")
    firstName = fields.Str(required=True, description="The first name of the user")
    lastName = fields.Str(required=True, description="The last name of the user")
    age = fields.Int(description="The age of the user")
</code></pre>
<h4 id="contract"><code>@contract</code></h4>
<h5 id="parameters">Parameters:</h5>
<ul>
<li><em>required</em> <em>(str)</em>: the name of the microservice dependency</li>
<li><em>required</em> <em>(str)</em>: the endpoint of the microservice dependency</li>
<li><strong>method</strong> <em>required</em> <em>(str)</em>: a single HTTP method</li>
<li><strong>many</strong> <em>(bool)</em>: If <code>True</code>, the OPTIONS endpoint should return an array of the model/schema, defaults to <code>False</code></li>
</ul>
<h3 id="2addoptionsmodelstoendpoints">2. Add OPTIONS models to endpoints</h3>
<p>Every endpoint created should have a model/schema to represent the data which that endpoint
accepts or returns when requested with a specified HTTP Method(s)</p>
<p>Additionally, in the case of PUT or POST requests, the JSON body will be validated against the corresponding model</p>
<p>By convention, these models should be created in the chlalicelib/models/options/ directory</p>
<p>These model files <strong>must be imported directly in the app.py or, better yet, imported in the
chalicelib/models/options/<strong>init</strong>.py  which must then be imported into the app.py</strong></p>
<p>The models can take the form of Marshmallow schemas or SQLAlchemy models</p>
<p>The <code>@register</code> decorator is used to link the schemas/models to an endpoint</p>
<pre><code class="python language-python">from marshmallow import Schema, fields
from contracttesting.handshake import register
from chalicelib.models.contract.users import User


@register('/featureFlags?userID=123', methods=['GET'], many=True)
class FeatureFlag(Schema):
    flagID = fields.UUID(required=True, description="A UUID to identify the feature flag")
    user = fields.Nested(User, required=True, description="The User who created the feature flag")
    flagName = fields.Str(required=True, description="The name of the feature flag")
    status = fields.Bool(required=True, description="The status of the flag, True=on, False=off")
</code></pre>
<p>Alternatively, if the data returned by the endpoint is identical to that represented by a SQLAlchemy model,
the SQLAlchemy model can be registered directly</p>
<pre><code class="python language-python">import sqlalchemy as sa
from sqlalchemy.ext.declarative import declarative_base
from contracttesting.handshake import register


Base = declarative_base()

@register('/featureFlags/{userID}', methods=['GET'])
class FeatureFlag(Base):
    __tablename__ = 'feature_flags'
    flagID = sa.Column(postgres.UUID(as_uuid=True), primary_key=True)
    userID = sa.Column(postgres.UUID(as_uuid=True), primary_key=True)
    flagName = sa.Column(sa.String, nullable=False)
    status = sa.Column(sa.Boolean, nullable=False)
</code></pre>
<h4 id="register"><code>@register</code></h4>
<h5 id="parameters-1">Parameters:</h5>
<ul>
<li><em>required</em> <em>(str)</em>: the endpoint being linked to the schema/model</li>
<li><strong>methods</strong> <em>required</em> <em>(list)</em>: a list of the HTTP methods</li>
<li><strong>many</strong> <em>(bool)</em>: If <code>True</code>, the OPTIONS endpoint should return an array of the model/schema, defaults to <code>False</code></li>
<li><strong>params</strong> <em>(dict)</em>: an optional dictionary of params, each of which accepts a dictionary value of additional information in the format specified by the <a href="http://swagger.io/specification/#fixed-fields-45">Swagger Specification</a></li>
<li><strong>paging</strong> <em>(bool)</em>: If <code>True</code>, the response object is wrapped in paging metadata, defaults to <code>False</code>, requires <code>many=True</code></li>
<li><strong>microservice</strong> <em>(str)</em>: The name of the microservice. Must pass this keyword argument to enable testing the endpoint from within the <code>Swagger UI</code>.</li>
</ul>
<pre><code class="python language-python">    {
        count: 37,
        limit: 50,
        page: 2
        data: [...]
    }
</code></pre>
<h3 id="3makemodelaccessibleviaoptionsrequestatendpoint">3. Make model accessible via OPTIONS request at endpoint</h3>
<p>In the app.py fileâ€¦</p>
<ol>
<li>Import the chalicelib.models.options package or the individual OPTIONS model files</li>
<li>Add OPTIONS to the list of accepted methods</li>
<li>Add the <code>@options</code> decorator <em>beneath</em> the Chalice <code>@app.route</code> decorator</li>
</ol>
<pre><code class="python language-python">import chalicelib.models.options


@app.route('/featureFlags', methods=['GET', 'OPTIONS'])
@options
def get_feature_flags(userID):
    pass
</code></pre>
<h4 id="options"><code>@options</code></h4>
<h5 id="parametersnone">Parameters: <em>None</em></h5>
<h2 id="backwardscompatibilitytesting">Backwards Compatibility Testing</h2>
<p>The goal of backwards compatibility testing is to prevent breaking changes from being introduced into 
a microservice. A breaking change can be described as one of the following</p>
<ol>
<li>A route is removed</li>
<li>The resource of a route is modified in one of the following ways<ol>
<li>A property is removed</li>
<li>The type of a property is modified</li></ol></li>
</ol>
<p>The changes are determined by storing and comparing snapshots of the APIs after a change is introduced.
The snapshots are represented by sam.json and swagger.json files, which must be stored in an AWS s3 bucket
after a successful build. Then, the contracttesting API can retrieve these files and compare the previous 
snapshot to the current snapshot.</p>
<p>The backwards compatibility testing CLI is described below.</p>
<p>An example of the CLI in a build script can be found <a href="https://gitlab.encirca.auto.pioneer.com/encirca-microservices/service-template/blob/master/run_all_tests.sh">here</a></p>
<h2 id="cli">CLI</h2>
<h3 id="outputautogeneratedswagger">Output autogenerated Swagger</h3>
<pre><code class="bash language-bash">$ contract swagger
</code></pre>
<h3 id="runcontracttests">Run contract tests</h3>
<pre><code class="bash language-bash">$ contract run
</code></pre>
<h3 id="comparesamjsonvsswaggerjson">Compare sam.json vs. swagger.json</h3>
<p>compare sam.json generated by <code>chalice package</code> against swagger.json generated by contract testing</p>
<p>Ensures that all routes in the app.py have been registered via <code>@register(...)</code></p>
<pre><code class="bash language-bash">$ contract compare_swagger "${CHALICE_PKG}/sam.json"
</code></pre>
<h3 id="comparesamjson">Compare sam.json</h3>
<p>compare previous Chalice-generated sam.json against current Chalice-generated sam.json</p>
<p>Ensures that no routes, excluding v0, have been removed from <code>app.py</code>.</p>
<p>The previous sam.json is stored in an AWS S3 bucket, following the naming scheme:
<code>api.&lt;environment&gt;.encirca.pioneer.com</code>. This value can be parsed from the <code>config/config.ini</code>
file in the microservice root directory.</p>
<p>The path in the bucket, by convention, generally adheres to the following naming scheme:
<code>&lt;microservice-name&gt;-&lt;environment&gt;-swagger.json</code>. After successful execution of this command, 
the sam.json should be updated via: <code>aws s3 mv &lt;new_sam.json&gt; &lt;old_sam.json&gt;</code></p>
<p><strong>NOTE: This command must be commented out in the initial build process to allow copying of
the initial sam.json to the s3 bucket.</strong></p>
<pre><code class="bash language-bash">$ contract compare_sam --bucket ${SWAGGER_BUCKET} --key ${NEW_SAM_JSON} "${CHALICE_PKG}/sam.json"
</code></pre>
<h3 id="compareswaggerjson">Compare swagger.json</h3>
<p>compare previous contracttesting swagger.json against current contracttesting swagger.json</p>
<p>Ensures that no properties of the registered models have been modified or removed</p>
<p>The previous swagger.json is stored in an AWS S3 bucket, following the naming scheme:
<code>api.&lt;environment&gt;.encirca.pioneer.com</code>. This value can be parsed from the <code>config/config.ini</code>
file in the microservice root directory.</p>
<p>The path in the bucket, by convention, generally adheres to the following naming scheme:
<code>&lt;microservice-name&gt;-&lt;environment&gt;-swagger.json</code>. After successful execution of this command, 
the swagger.json should be updated via: <code>aws s3 mv &lt;new_swagger.json&gt; &lt;old_swagger.json&gt;</code></p>
<p><strong>NOTE: This command must be commented out in the initial build process to allow copying of
the initial sam.json to the s3 bucket.</strong></p>
<pre><code class="bash language-bash">$ contract back --bucket ${SWAGGER_BUCKET}  --key ${NEW_CONTRACT_SWAGGER}
</code></pre>
<p><strong>NOTE: All <code>contract</code> CLI commands must be run from the svc directory of microservice</strong></p>
<p>The contract-testing project is open source, meaning that all suggestions and contributions are not only welcome but are
encouraged. Don't hesitate to create an Issue in GitLab if you identify a bug, and/or create a merge request to fix an
issue or add an enhancement. Additionally feel free to speak to Stingray directly about any
  questions/concerns/suggestions.</p>
      </main>
      
      
      <!--JavaScript at end of body for optimized loading-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0-beta/js/materialize.min.js"></script>
      <script>
	var elem = document.querySelector('.sidenav');
	var instance = M.Sidenav.init(elem);

      </script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
      <script>hljs.initHighlightingOnLoad();</script>

      
    </body>
  </html>
